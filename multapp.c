#include <stdio.h>
#include <time.h>
#include <limits.h>
#include <unistd.h>
#include <inttypes.h>
#include <stdlib.h>
#include <pthread.h>
#define radius 1
#define chck(X, Y) (((X * X + Y * Y) < radius))
struct cnds
{
    double *coordsptr;
    __uint128_t *state;
    unsigned int iters;
    unsigned int *counter;
};

void generatecoords_l(double *, __uint128_t *);
void *parasim(void *);
uint64_t lehmer64(__uint128_t *);

int main(int argc, char **argv)
{
    struct timespec start, end;
    unsigned int samples = 1000000;
    int opt, i, j;
    srand(time(NULL));
    while ((opt = getopt(argc, argv, ":n:hw")) != -1)
    {
        switch (opt)
        {
        case 'h':
            printf("options:\n-h\tfor help (display this message)");
            printf("\n-n\tto input number of coordinate pairs to approximate pi with.\n");
            printf("will approximate pi with 1000000 coordinate pairs generated by lehmer's generator if no arguments are provided.\n");
            return 0;
        case 'n':
            samples = atoll(optarg);
            break;
        case '?':
            printf("unkown option: %s\n", optopt);
            return -1;
        case ':':
            printf("option %s requires a value\n", optopt);
            return -1;
        }
    }
    if (samples == 0)
    {
        printf("Invalid size. Goodbye.\n");
        return 0;
    }

    clock_gettime(CLOCK_MONOTONIC, &start);
    int numCPU = sysconf(_SC_NPROCESSORS_ONLN);

    __uint128_t *state = (__uint128_t *)malloc(sizeof(__uint128_t) * numCPU);
    double **allcoordinates = (double **)malloc(sizeof(double *) * numCPU);

    for (i = 0; i < numCPU; i++)
    {
        allcoordinates[i] = (double *)malloc(sizeof(double) * 2);
        state[i] = (2 * (clock() + time(NULL) * clock()) + rand()) + 1;
    }
    state[0] = 2 * lehmer64(&state[0]) + 1;
    printf("%lu\n", state[0]);
    // numCPU -1 since we already have a thread for main
    pthread_t *threads = malloc((numCPU - 1) * sizeof(pthread_t));
    unsigned int *counter = calloc(numCPU, sizeof(uint));
    int iters = samples / numCPU;

    struct cnds *allst = malloc(numCPU * sizeof(struct cnds));
    for (i = 0; i < numCPU; i++)
    {
        allst[i].coordsptr = allcoordinates[i];
        allst[i].iters = iters;
        allst[i].state = &state[i];
        allst[i].counter = &(counter[i]);
    }

    for (i = 0; i < (numCPU - 1); i++)
    {
        pthread_create(&threads[i], NULL, (void *)&parasim, (void *)&(allst[i]));
    }
    parasim((void *)&allst[numCPU - 1]);

    for (i = 0; i < numCPU - 1; i++)
    {
        pthread_join(threads[i], NULL);
    }
    free(threads);
    free(state);

    for (i = 0; i < numCPU; i++)
    {
        free(allcoordinates[i]);
    }
    free(allcoordinates);

    // sum all counters
    int tot = 0;
    for (i = 0; i < numCPU; i++)
    {
        tot += *allst[i].counter;
    }

    double result = (double)tot / samples;
    free(counter);
    free(allst);
    result *= 4;
    clock_gettime(CLOCK_MONOTONIC, &end);
    double elapsedtime = (double)(end.tv_sec - start.tv_sec) + 1e-9 * (end.tv_nsec - start.tv_nsec);

    printf("Pi is roughly equal to %lf (sample size: %d). Elapsed time: About %lf seconds.\n", result, samples, elapsedtime);
    return 0;
}
// generate one set of coordinates between 0 and 1
void generatecoords_l(double *coords, __uint128_t *seed)
{
    int i;
    // create x and y coordinates between 0 and 1
    for (i = 0; i < 2; i++)
    {
        coords[i] = (double)lehmer64(seed) / ULLONG_MAX;
    }
}

// generate one set of coordinates between 0 and 1
void *parasim(void *inpyboi)
{
    struct cnds *candst = (struct cnds *)inpyboi;
    for (int i = 0; i < candst->iters; i++)
    {
        generatecoords_l(candst->coordsptr, candst->state);
        (*(candst->counter)) += (chck(candst->coordsptr[0], candst->coordsptr[1]));
    }
}

// lehmer64
// casting should be faster than bitshifting, it was when compiled with 0 optimization
// when compiled with more opt the compiler seems to give the same instruction, the times are identical.
// todo: why does it not work when multithreaded but it does when singlethreaded
uint64_t lehmer64(__uint128_t *state)
{
    *state *= 0xda942042e4dd58b5;
    return (uint64_t)(*state >> 64);
    // uint64_t *tst = (uint64_t *)state;
    // return *(tst + 1);
}
